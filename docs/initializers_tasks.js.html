<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>initializers/tasks.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ActionHero.html">ActionHero</a></li><li><a href="ActionHero.Action.html">Action</a><ul class='methods'><li data-type='method'><a href="ActionHero.Action.html#.run">run</a></li></ul></li><li><a href="ActionHero.CLI.html">CLI</a><ul class='methods'><li data-type='method'><a href="ActionHero.CLI.html#.run">run</a></li></ul></li><li><a href="ActionHero.Connection.html">Connection</a><ul class='methods'><li data-type='method'><a href="ActionHero.Connection.html#.destroy">destroy</a></li><li data-type='method'><a href="ActionHero.Connection.html#.localize">localize</a></li></ul></li><li><a href="ActionHero.Initializer.html">Initializer</a><ul class='methods'><li data-type='method'><a href="ActionHero.Initializer.html#.initialize">initialize</a></li><li data-type='method'><a href="ActionHero.Initializer.html#.start">start</a></li><li data-type='method'><a href="ActionHero.Initializer.html#.stop">stop</a></li></ul></li><li><a href="ActionHero.Server.html">Server</a><ul class='methods'><li data-type='method'><a href="ActionHero.Server.html#.buildConnection">buildConnection</a></li><li data-type='method'><a href="ActionHero.Server.html#.connections">connections</a></li><li data-type='method'><a href="ActionHero.Server.html#.initialize">initialize</a></li><li data-type='method'><a href="ActionHero.Server.html#.log">log</a></li><li data-type='method'><a href="ActionHero.Server.html#.processAction">processAction</a></li><li data-type='method'><a href="ActionHero.Server.html#.processFile">processFile</a></li><li data-type='method'><a href="ActionHero.Server.html#.sendFile">sendFile</a></li><li data-type='method'><a href="ActionHero.Server.html#.sendMessage">sendMessage</a></li><li data-type='method'><a href="ActionHero.Server.html#.start">start</a></li><li data-type='method'><a href="ActionHero.Server.html#.stop">stop</a></li></ul></li><li><a href="ActionHero.Task.html">Task</a><ul class='methods'><li data-type='method'><a href="ActionHero.Task.html#.run">run</a></li></ul></li><li><a href="api.specHelper.Connection.html">Connection</a></li></ul><h3>Events</h3><ul><li><a href="ActionHero.Server.html#event:actionComplete">actionComplete</a></li><li><a href="ActionHero.Server.html#event:connection">connection</a></li></ul><h3>Namespaces</h3><ul><li><a href="api.html">api</a><ul class='methods'><li data-type='method'><a href="api.html#.log">log</a></li><li data-type='method'><a href="api.html#.unWatchAllFiles">unWatchAllFiles</a></li><li data-type='method'><a href="api.html#.watchFileAndAct">watchFileAndAct</a></li></ul></li><li><a href="api.actions.html">actions</a><ul class='methods'><li data-type='method'><a href="api.actions.html#.addMiddleware">addMiddleware</a></li></ul></li><li><a href="api.cache.html">cache</a><ul class='methods'><li data-type='method'><a href="api.cache.html#.clear">clear</a></li><li data-type='method'><a href="api.cache.html#.destroy">destroy</a></li><li data-type='method'><a href="api.cache.html#.dumpRead">dumpRead</a></li><li data-type='method'><a href="api.cache.html#.dumpWrite">dumpWrite</a></li><li data-type='method'><a href="api.cache.html#.keys">keys</a></li><li data-type='method'><a href="api.cache.html#.listLength">listLength</a></li><li data-type='method'><a href="api.cache.html#.load">load</a></li><li data-type='method'><a href="api.cache.html#.lock">lock</a></li><li data-type='method'><a href="api.cache.html#.locks">locks</a></li><li data-type='method'><a href="api.cache.html#.pop">pop</a></li><li data-type='method'><a href="api.cache.html#.push">push</a></li><li data-type='method'><a href="api.cache.html#.save">save</a></li><li data-type='method'><a href="api.cache.html#.size">size</a></li><li data-type='method'><a href="api.cache.html#.unlock">unlock</a></li></ul></li><li><a href="api.chatRoom.html">chatRoom</a><ul class='methods'><li data-type='method'><a href="api.chatRoom.html#.add">add</a></li><li data-type='method'><a href="api.chatRoom.html#.addMember">addMember</a></li><li data-type='method'><a href="api.chatRoom.html#.addMiddleware">addMiddleware</a></li><li data-type='method'><a href="api.chatRoom.html#.broadcast">broadcast</a></li><li data-type='method'><a href="api.chatRoom.html#.destroy">destroy</a></li><li data-type='method'><a href="api.chatRoom.html#.exists">exists</a></li><li data-type='method'><a href="api.chatRoom.html#.generateMemberDetails">generateMemberDetails</a></li><li data-type='method'><a href="api.chatRoom.html#.list">list</a></li><li data-type='method'><a href="api.chatRoom.html#.removeMember">removeMember</a></li><li data-type='method'><a href="api.chatRoom.html#.roomStatus">roomStatus</a></li><li data-type='method'><a href="api.chatRoom.html#.sanitizeMemberDetails">sanitizeMemberDetails</a></li></ul></li><li><a href="api.config.html">config</a></li><li><a href="api.connections.html">connections</a><ul class='methods'><li data-type='method'><a href="api.connections.html#.addMiddleware">addMiddleware</a></li></ul></li><li><a href="api.documentation.html">documentation</a></li><li><a href="api.exceptions.html">exceptions</a></li><li><a href="api.i18n.html">i18n</a><ul class='methods'><li data-type='method'><a href="api.i18n.html#.localize">localize</a></li></ul></li><li><a href="api.id.html">id</a></li><li><a href="api.params.html">params</a></li><li><a href="api.pids.html">pids</a></li><li><a href="api.redis.html">redis</a><ul class='methods'><li data-type='method'><a href="api.redis.html#.doCluster">doCluster</a></li></ul></li><li><a href="api.resque.html">resque</a></li><li><a href="api.routes.html">routes</a><ul class='methods'><li data-type='method'><a href="api.routes.html#.registerRoute">registerRoute</a></li></ul></li><li><a href="api.servers.html">servers</a></li><li><a href="api.specHelper.html">specHelper</a><ul class='methods'><li data-type='method'><a href="api.specHelper.html#.getStaticFile">getStaticFile</a></li><li data-type='method'><a href="api.specHelper.html#.runAction">runAction</a></li><li data-type='method'><a href="api.specHelper.html#.runFullTask">runFullTask</a></li><li data-type='method'><a href="api.specHelper.html#.runTask">runTask</a></li></ul></li><li><a href="api.staticFile.html">staticFile</a><ul class='methods'><li data-type='method'><a href="api.staticFile.html#.get">get</a></li></ul></li><li><a href="api.tasks.html">tasks</a><ul class='methods'><li data-type='method'><a href="api.tasks.html#.allDelayed">allDelayed</a></li><li data-type='method'><a href="api.tasks.html#.allWorkingOn">allWorkingOn</a></li><li data-type='method'><a href="api.tasks.html#.cleanOldWorkers">cleanOldWorkers</a></li><li data-type='method'><a href="api.tasks.html#.del">del</a></li><li data-type='method'><a href="api.tasks.html#.delayedAt">delayedAt</a></li><li data-type='method'><a href="api.tasks.html#.delDelayed">delDelayed</a></li><li data-type='method'><a href="api.tasks.html#.delLock">delLock</a></li><li data-type='method'><a href="api.tasks.html#.delQueue">delQueue</a></li><li data-type='method'><a href="api.tasks.html#.details">details</a></li><li data-type='method'><a href="api.tasks.html#.enqueue">enqueue</a></li><li data-type='method'><a href="api.tasks.html#.enqueueAllRecurrentTasks">enqueueAllRecurrentTasks</a></li><li data-type='method'><a href="api.tasks.html#.enqueueAt">enqueueAt</a></li><li data-type='method'><a href="api.tasks.html#.enqueueIn">enqueueIn</a></li><li data-type='method'><a href="api.tasks.html#.enqueueRecurrentTask">enqueueRecurrentTask</a></li><li data-type='method'><a href="api.tasks.html#.failed">failed</a></li><li data-type='method'><a href="api.tasks.html#.failedCount">failedCount</a></li><li data-type='method'><a href="api.tasks.html#.locks">locks</a></li><li data-type='method'><a href="api.tasks.html#.queued">queued</a></li><li data-type='method'><a href="api.tasks.html#.removeFailed">removeFailed</a></li><li data-type='method'><a href="api.tasks.html#.retryAndRemoveFailed">retryAndRemoveFailed</a></li><li data-type='method'><a href="api.tasks.html#.scheduledAt">scheduledAt</a></li><li data-type='method'><a href="api.tasks.html#.stats">stats</a></li><li data-type='method'><a href="api.tasks.html#.stopRecurrentTask">stopRecurrentTask</a></li><li data-type='method'><a href="api.tasks.html#.timestamps">timestamps</a></li><li data-type='method'><a href="api.tasks.html#.workers">workers</a></li><li data-type='method'><a href="api.tasks.html#.workingOn">workingOn</a></li></ul></li><li><a href="api.utils.html">utils</a><ul class='methods'><li data-type='method'><a href="api.utils.html#.arrayUniqueify">arrayUniqueify</a></li><li data-type='method'><a href="api.utils.html#.asyncWaterfall">asyncWaterfall</a></li><li data-type='method'><a href="api.utils.html#.collapseObjectToArray">collapseObjectToArray</a></li><li data-type='method'><a href="api.utils.html#.createDirSafely">createDirSafely</a></li><li data-type='method'><a href="api.utils.html#.createFileSafely">createFileSafely</a></li><li data-type='method'><a href="api.utils.html#.createLinkfileSafely">createLinkfileSafely</a></li><li data-type='method'><a href="api.utils.html#.createSymlinkSafely">createSymlinkSafely</a></li><li data-type='method'><a href="api.utils.html#.dirExists">dirExists</a></li><li data-type='method'><a href="api.utils.html#.eventLoopDelay">eventLoopDelay</a></li><li data-type='method'><a href="api.utils.html#.fileExists">fileExists</a></li><li data-type='method'><a href="api.utils.html#.filterObjectForLogging">filterObjectForLogging</a></li><li data-type='method'><a href="api.utils.html#.getExternalIPAddress">getExternalIPAddress</a></li><li data-type='method'><a href="api.utils.html#.hashMerge">hashMerge</a></li><li data-type='method'><a href="api.utils.html#.parseCookies">parseCookies</a></li><li data-type='method'><a href="api.utils.html#.parseIPv6URI">parseIPv6URI</a></li><li data-type='method'><a href="api.utils.html#.recursiveDirectoryGlob">recursiveDirectoryGlob</a></li><li data-type='method'><a href="api.utils.html#.removeLinkfileSafely">removeLinkfileSafely</a></li><li data-type='method'><a href="api.utils.html#.sortGlobalMiddleware">sortGlobalMiddleware</a></li></ul></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-actions.html">actions</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">initializers/tasks.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict'

const NodeResque = require('node-resque')
const ActionHero = require('./../index.js')
const api = ActionHero.api

/**
 * This callback is displayed as part of the Requester class.
 * @callback ActionHero~TaskCallback
 * @param {Object} this.worker - The task worker, if this is a pre or post process step.
 * @param {Object} this.args - If this is a queue step, the arguemnts to the task
 * @param {Object} this.queue - The queue to be used / is being used.
 * @see ActionHero~TaskMiddleware
 */

/**
 * Middleware definition for Actions
 *
 * @typedef {Object} ActionHero~TaskMiddleware
 * @property {string} name - Unique name for the middleware.
 * @property {Boolean} global - Is this middleware applied to all tasks?
 * @property {Number} priority - Module load order. Defaults to `api.config.general.defaultMiddlewarePriority`.
 * @property {ActionHero~TaskCallback} preProcessor - Called berore the action runs.  Has access to all params, before sanitizartion.  Can modify the data object for use in actions.
 * @property {ActionHero~TaskCallback} postProcessor - Called after the action runs.
 * @property {ActionHero~TaskCallback} preEnqueue - Called before a task using this middleware is enqueud.
 * @property {ActionHero~TaskCallback} postEnqueue - Called after a task using this middleware is enqueud.
 * @see api.actions.addMiddleware
 * @example
api.taskTimer = {
  middleware: {
    name: 'timer',
    global: true,
    priority: 90,
    preProcessor: function(next){
      var worker = this.worker;
      worker.start = process.hrtime();
      next();
    },
    postProcessor: function(next){
      var worker = this.worker;
      var elapsed = process.hrtime(worker.start);
      var seconds = elapsed[0];
      var millis = elapsed[1] / 1000000;
      api.log(worker.job.class + ' done in ' + seconds + ' s and ' + millis + ' ms.', 'info');
      next();
    },
    preEnqueue: function(next){
      var params = this.args[0];
      //Validate params
      next(null, true); //callback is in form cb(error, toRun)
    },
    postEnqueue: function(next){
      api.log("Task successfully enqueued!");
      next();
    }
  }
};

api.tasks.addMiddleware(api.taskTimer.middleware);
 */

/**
 * Tools for enquing and inspecting the task sytem (delayed jobs).
 *
 * @namespace api.tasks
 * @property {Object} tasks - The tasks defined on this server.
 * @property {Object} jobs - The tasks defined on this server, converted into Node Resque jobs.
 * @property {Object} middleware - Available Task Middleware.
 * @property {Array} globalMiddleware - Array of global middleware modules.
 * @extends ActionHero.Initializer
 */
module.exports = class Tasks extends ActionHero.Initializer {
  constructor () {
    super()
    this.name = 'tasks'
    this.loadPriority = 699
    this.startPriority = 900
  }

  initialize () {
    api.tasks = {
      tasks: {},
      jobs: {},
      middleware: {},
      globalMiddleware: []
    }

    /**
     * @private
     */
    api.tasks.loadFile = (fullFilePath, reload) => {
      if (!reload) { reload = false }

      api.watchFileAndAct(fullFilePath, () => {
        api.tasks.loadFile(fullFilePath, true)
      })

      let task
      let collection = require(fullFilePath)
      if (typeof collection === 'function') { collection = [collection] }
      for (let i in collection) {
        const TaskClass = collection[i]
        task = new TaskClass()
        task.validate()
        api.tasks.tasks[task.name] = task
        api.tasks.jobs[task.name] = api.tasks.jobWrapper(task.name)
        api.log(`task ${(reload ? '(re)' : '')} loaded: ${task.name}, ${fullFilePath}`, 'debug')
      }
    }

    /**
     * @private
     */
    api.tasks.jobWrapper = (taskName) => {
      const task = api.tasks.tasks[taskName]

      let middleware = task.middleware || []
      let plugins = task.plugins || []
      let pluginOptions = task.pluginOptions || []

      if (task.frequency > 0) {
        if (plugins.indexOf('JobLock') &lt; 0) { plugins.push('JobLock') }
        if (plugins.indexOf('QueueLock') &lt; 0) { plugins.push('QueueLock') }
        if (plugins.indexOf('DelayQueueLock') &lt; 0) { plugins.push('DelayQueueLock') }
      }

      // load middleware into plugins
      const processMiddleware = (m) => {
        if (api.tasks.middleware[m]) {
          class Plugin extends NodeResque.Plugin {}
          if (api.tasks.middleware[m].preProcessor) { Plugin.prototype.beforePerform = api.tasks.middleware[m].preProcessor }
          if (api.tasks.middleware[m].postProcessor) { Plugin.prototype.afterPerform = api.tasks.middleware[m].postProcessor }
          if (api.tasks.middleware[m].preEnqueue) { Plugin.prototype.beforeEnqueue = api.tasks.middleware[m].preEnqueue }
          if (api.tasks.middleware[m].postEnqueue) { Plugin.prototype.afterEnqueue = api.tasks.middleware[m].postEnqueue }
          plugins.push(Plugin)
        }
      }

      api.tasks.globalMiddleware.forEach(processMiddleware)
      middleware.forEach(processMiddleware)

      return {
        plugins: plugins,
        pluginOptions: pluginOptions,
        perform: async function () {
          let combinedArgs = [].concat(Array.prototype.slice.call(arguments))
          let response = await api.tasks.tasks[taskName].run.apply(this, combinedArgs)
          await api.tasks.enqueueRecurrentTask(taskName)
          return response
        }
      }
    }

    /**
     * Enqueue a task to be performed in the background.
     * Will throw an error if redis cannot be reached.
     *
     * @async
     * @param  {String}  taskName The name of the task.
     * @param  {Object}  params   Params to pass to the task.
     * @param  {string}  queue    (Optional) Which queue/priority to run this instance of the task on.
     * @return {Promise&lt;Boolean>} Did the task enqueue?
     */
    api.tasks.enqueue = async (taskName, params, queue) => {
      if (!params) { params = {} }
      if (!queue) { queue = api.tasks.tasks[taskName].queue }
      return api.resque.queue.enqueue(queue, taskName, params)
    }

    /**
     * Enqueue a task to be performed in the background, at a certain time in the future.
     * Will throw an error if redis cannot be reached.
     *
     * @param  {Number}  timestamp At what time the task is able to be run.  Does not gaurentee that the task will be run at this time. (in ms)
     * @param  {String}  taskName  The name of the task.
     * @param  {Object}  params    Params to pass to the task.
     * @param  {string}  queue     (Optional) Which queue/priority to run this instance of the task on.
     * @return {Promise}
     */
    api.tasks.enqueueAt = async (timestamp, taskName, params, queue) => {
      if (!params) { params = {} }
      if (!queue) { queue = api.tasks.tasks[taskName].queue }
      return api.resque.queue.enqueueAt(timestamp, queue, taskName, params)
    }

    /**
     * Enqueue a task to be performed in the background, at a certain number of ms from now.
     * Will throw an error if redis cannot be reached.
     *
     * @param  {Number}  time     How long from now should we wait until it is OK to run this task? (in ms)
     * @param  {String}  taskName The name of the task.
     * @param  {Object}  params   Params to pass to the task.
     * @param  {string}  queue    (Optional) Which queue/priority to run this instance of the task on.
     * @return {Promise}
     */
    api.tasks.enqueueIn = async (time, taskName, params, queue) => {
      if (!params) { params = {} }
      if (!queue) { queue = api.tasks.tasks[taskName].queue }
      return api.resque.queue.enqueueIn(time, queue, taskName, params)
    }

    /**
     * Delete a previously enqueued task, which hasn't been run yet, from a queue.
     * Will throw an error if redis cannot be reached.
     *
     * @param  {string}  q          Which queue/priority is the task stored on?
     * @param  {string}  taskName   The name of the job, likley to be the same name as a tak.
     * @param  {Object|Array} args  The arguments of the job.  Note, arguments passed to a Task initially may be modified when enqueuing.
     *                              It is best to read job properties first via `api.tasks.queued` or similar method.
     * @param  {Number}  count      Of the jobs that match q, taskName, and args, up to what position should we delete? (Default 0; this command is 0-indexed)
     * @return {Promise}
     */
    api.tasks.del = async (q, taskName, args, count) => {
      return api.resque.queue.del(q, taskName, args, count)
    }

    /**
     * Delete all previously enqueued tasks, which hasn't been run yet, from all possible delayed timestamps.
     * Will throw an error if redis cannot be reached.
     *
     * @param  {string}  q          Which queue/priority is to run on?
     * @param  {string}  taskName   The name of the job, likley to be the same name as a tak.
     * @param  {Object|Array} args  The arguments of the job.  Note, arguments passed to a Task initially may be modified when enqueuing.
     *                              It is best to read job properties first via `api.tasks.delayedAt` or similar method.
     * @return {Promise}
     */
    api.tasks.delDelayed = async (q, taskName, args) => {
      return api.resque.queue.delDelayed(q, taskName, args)
    }

    /**
     * Return the timestamps a task is scheduled for.
     * Will throw an error if redis cannot be reached.
     *
     * @async
     * @param  {string}  q          Which queue/priority is to run on?
     * @param  {string}  taskName   The name of the job, likley to be the same name as a tak.
     * @param  {Object|Array} args  The arguments of the job.  Note, arguments passed to a Task initially may be modified when enqueuing.
     *                              It is best to read job properties first via `api.tasks.delayedAt` or similar method.
     * @return {Promise&lt;Arra>}    Returns an array of timestamps.
     */
    api.tasks.scheduledAt = async (q, taskName, args) => {
      return api.resque.queue.scheduledAt(q, taskName, args)
    }

    /**
     * Return all resque stats for this namespace (how jobs failed, jobs succeded, etc)
     * Will throw an error if redis cannot be reached.
     *
     * @async
     * @return {Promise&lt;Object>} (varies on your redis instance)
     */
    api.tasks.stats = async () => {
      return api.resque.queue.stats()
    }

    /**
     * Retrieve the details of jobs enqueued on a certain queue between start and stop (0-indexed)
     * Will throw an error if redis cannot be reached.
     *
     * @async
     * @param  {string}  q      The name of the queue.
     * @param  {Number}  start  The index of the first job to return.
     * @param  {Number}  stop   The index of the last job to return.
     * @return {Promise&lt;Array>} An array of the jobs enqueued.
     */
    api.tasks.queued = async (q, start, stop) => {
      return api.resque.queue.queued(q, start, stop)
    }

    /**
     * Delete a queue in redis, and all jobs stored on it.
     * Will throw an error if redis cannot be reached.
     *
     * @async
     * @param  {string}  q The name of the queue.
     * @return {Promise}
     */
    api.tasks.delQueue = async (q) => {
      return api.resque.queue.delQueue(q)
    }

    /**
     * Return any locks, as created by resque plugins or task middleware, in this redis namespace.
     * Will contain locks with keys like `resque:lock:{job}` and `resque:workerslock:{workerId}`
     * Will throw an error if redis cannot be reached.
     *
     * @async
     * @return {Promise|Object} Locks, orginzed by type.
     */
    api.tasks.locks = async () => {
      return api.resque.queue.locks()
    }

    /**
     * Delete a lock on a job or worker.  Locks can be found via `api.tasks.locks`
     * Will throw an error if redis cannot be reached.
     *
     * @async
     * @param  {string}  lock The name of the lock.
     * @return {Promise}
     * @see api.tasks.locks
     */
    api.tasks.delLock = async (lock) => {
      return api.resque.queue.delLock(lock)
    }

    /**
     * List all timestamps for which tasks are enqueued in the future, via `api.tasks.enqueueIn` or `api.tasks.enqueueAt`
     * Will throw an error if redis cannot be reached.
     *
     * @async
     * @return {Promise&lt;Array>} An array of timetamps. Note: These timestamps will be in unix timestamps, not javascript MS timestamps.
     * @see api.tasks.enqueueIn
     * @see api.tasks.enqueueAt
     */
    api.tasks.timestamps = async () => {
      return api.resque.queue.timestamps()
    }

    /**
     * Return all jobs which have been enqueued to run at a certain timestamp.
     * Will throw an error if redis cannot be reached.
     *
     * @async
     * @param  {Number}  timestamp The timestamp to return jobs from.  Note: timestamp will be a unix timestamp, not javascript MS timestamp.
     * @return {Promise&lt;Array>}    An array of jobs.
     */
    api.tasks.delayedAt = async (timestamp) => {
      return api.resque.queue.delayedAt(timestamp)
    }

    /**
     * Retrun all delayed jobs, orginized by the timetsamp at where they are to run at.
     * Note: This is a very slow command.
     * Will throw an error if redis cannot be reached.
     *
     * @async
     * @return {Promise&lt;Object>}
     */
    api.tasks.allDelayed = async () => {
      return api.resque.queue.allDelayed()
    }

    /**
     * Retrun all workers registered by all members of this cluster.
     * Note: MultiWorker processors each register as a unique worker.
     * Will throw an error if redis cannot be reached.
     *
     * @async
     * @return {Promise&lt;Object>}
     */
    api.tasks.workers = async () => {
      return api.resque.queue.workers()
    }

    /**
     * What is a given worker working on?  If the worker is idle, 'started' will be returned.
     * Will throw an error if redis cannot be reached.
     *
     * @async
     * @param  {string}  workerName The worker base name, usually a function of the PID.
     * @param  {string}  queues     The queues the worker is assigned to work.
     * @return {Promise&lt;Object>}
     */
    api.tasks.workingOn = async (workerName, queues) => {
      return api.resque.queue.workingOn(workerName, queues)
    }

    /**
     * Return all workers and what job they might be working on.
     * Will throw an error if redis cannot be reached.
     *
     * @async
     * @return {Promise&lt;Object>} An Object, with worker names as keys, containing the job they are working on.
     *                           If the worker is idle, 'started' will be returned.
     */
    api.tasks.allWorkingOn = async () => {
      return api.resque.queue.allWorkingOn()
    }

    /**
     * How many jobs are in the failed queue.
     * Will throw an error if redis cannot be reached.
     *
     * @async
     * @return {Promise&lt;Number>} The number of failed jobs at this moment.
     */
    api.tasks.failedCount = async () => {
      return api.resque.queue.failedCount()
    }

    /**
     * Retrieve the details of failed jobs between start and stop (0-indexed).
     * Will throw an error if redis cannot be reached.
     *
     * @async
     * @param  {Number}  start  The index of the first job to return.
     * @param  {Number}  stop   The index of the last job to return.
     * @return {Promise&lt;Array>} An array of the failed jobs.
     */
    api.tasks.failed = async (start, stop) => {
      return api.resque.queue.failed(start, stop)
    }

    /**
     * Remove a specific job from the failed queue.
     * Will throw an error if redis cannot be reached.
     *
     * @async
     * @param  {Object}  failedJob The failed job, as defined by `api.tasks.failed`
     * @return {Promise}
     * @see api.tasks.failed
     */
    api.tasks.removeFailed = async (failedJob) => {
      return api.resque.queue.removeFailed(failedJob)
    }

    /**
     * Remove a specific job from the failed queue, and retry it by placing it back into its original queue.
     * Will throw an error if redis cannot be reached.
     *
     * @async
     * @param  {Object}  failedJob The failed job, as defined by `api.tasks.failed`
     * @return {Promise}
     * @see api.tasks.failed
     */
    api.tasks.retryAndRemoveFailed = async (failedJob) => {
      return api.resque.queue.retryAndRemoveFailed(failedJob)
    }

    /**
     * If a worker process crashes, it will leave its state in redis as "working".
     * You can remove workers from redis you know to be over, by specificing an age which would make them too old to exist.
     * This method will remove the data created by a 'stuck' worker and move the payload to the error queue.
     * However, it will not actually remove any processes which may be running.  A job *may* be running that you have removed.
     * Will throw an error if redis cannot be reached.
     *
     * @async
     * @param  {Number}  age The age of workers you know to be over, in seconds.
     * @return {Promise&lt;ObjecT>} Details about workers which were removed.
     */
    api.tasks.cleanOldWorkers = async (age) => {
      return api.resque.queue.cleanOldWorkers(age)
    }

    /**
     * Ensures that a task which has a frequency is either running, or already enqueued.
     * This is run automatically at boot for all tasks which have a frequency, via `api.tasks.enqueueAllRecurrentTasks`.
     * Will throw an error if redis cannot be reached.
     *
     * @async
     * @param  {string}  taskName The name of the task.
     * @return {Promise}
     * @see api.tasks.enqueueAllRecurrentTasks
     */
    api.tasks.enqueueRecurrentTask = async (taskName) => {
      const task = api.tasks.tasks[taskName]

      if (task.frequency > 0) {
        await api.tasks.del(task.queue, taskName)
        await api.tasks.delDelayed(task.queue, taskName)
        await api.tasks.enqueueIn(task.frequency, taskName)
        api.log(`re-enqueued recurrent job ${taskName}`, api.config.tasks.schedulerLogging.reEnqueue)
      }
    }

    /**
     * This is run automatically at boot for all tasks which have a frequency, calling `api.tasks.enqueueRecurrentTask`
     * Will throw an error if redis cannot be reached.
     *
     * @async
     * @return {Promise}
     * @see api.tasks.enqueueRecurrentTask
     */
    api.tasks.enqueueAllRecurrentTasks = async () => {
      let jobs = []
      let loadedTasks = []

      Object.keys(api.tasks.tasks).forEach((taskName) => {
        const task = api.tasks.tasks[taskName]
        if (task.frequency > 0) {
          jobs.push(async () => {
            let toRun = await api.tasks.enqueue(taskName)
            if (toRun === true) {
              api.log(`enqueuing periodic task: ${taskName}`, api.config.tasks.schedulerLogging.enqueue)
              loadedTasks.push(taskName)
            }
          })
        }
      })

      await api.utils.asyncWaterfall(jobs)
      return loadedTasks
    }

    /**
     * Stop a task with a frequency by removing it from all possible queues.
     * Will throw an error if redis cannot be reached.
     *
     * @async
     * @param  {string}  taskName The name of the task.
     * @return {Promise&lt;Number>}  How many tasks were removed.
     */
    api.tasks.stopRecurrentTask = async (taskName) => {
      // find the jobs in either the normal queue or delayed queues
      const task = api.tasks.tasks[taskName]
      if (task.frequency > 0) {
        let removedCount = 0
        let count = await api.tasks.del(task.queue, task.name, {}, 1)
        removedCount = removedCount + count
        let timestamps = await api.tasks.delDelayed(task.queue, task.name, {})
        removedCount = removedCount + timestamps.length
        return removedCount
      }
    }

    /**
     * Reurn wholistic details about the whole task system, including failures, queues, and workers.
     * Will throw an error if redis cannot be reached.
     *
     * @async
     * @return {Promise} [description]
     */
    api.tasks.details = async () => {
      let details = {'queues': {}, 'workers': {}}

      details.workers = await api.tasks.allWorkingOn()
      details.stats = await api.tasks.stats()
      let queues = await api.resque.queue.queues()

      for (let i in queues) {
        let queue = queues[i]
        let length = await api.resque.queue.length(queue)
        details.queues[queue] = { length: length }
      }

      return details
    }

    api.tasks.loadTasks = (reload) => {
      api.config.general.paths.task.forEach((p) => {
        api.utils.recursiveDirectoryGlob(p).forEach((f) => {
          api.tasks.loadFile(f, reload)
        })
      })
    }

    api.tasks.addMiddleware = (middleware) => {
      if (!middleware.name) { throw new Error('middleware.name is required') }
      if (!middleware.priority) { middleware.priority = api.config.general.defaultMiddlewarePriority }
      middleware.priority = Number(middleware.priority)
      api.tasks.middleware[middleware.name] = middleware
      if (middleware.global === true) {
        api.tasks.globalMiddleware.push(middleware.name)
        api.utils.sortGlobalMiddleware(api.tasks.globalMiddleware, api.tasks.middleware)
      }
      api.tasks.loadTasks(true)
    }

    api.tasks.loadTasks(false)
  }

  async start () {
    if (api.config.redis.enabled === false) { return }

    if (api.config.tasks.scheduler === true) {
      await api.tasks.enqueueAllRecurrentTasks()
    }
  }
}
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Learn more about ActionHero @ <a href="https://www.actionherojs.com">www.actionherojs.com</a>
    <br />
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> using the <a href="https://github.com/actionhero/docdash-actionhero-theme">docdash-actionhero-theme</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
